"use strict";(globalThis.webpackChunkwalrus_docusaurus=globalThis.webpackChunkwalrus_docusaurus||[]).push([[4750],{5756(e,t,n){n.d(t,{R:()=>o,x:()=>h});var s=n(9471);let i={},r=s.createContext(i);function o(e){let t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function h(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:t},e.children)}},7225(e,t,n){n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>h,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});let s=JSON.parse('{"id":"operator-guide/auth-publisher","title":"The Authenticated Publisher","description":"Guide to setting up and using authenticated Walrus publishers with JWT authentication for controlled blob storage access.","source":"@site/../content/operator-guide/auth-publisher.mdx","sourceDirName":"operator-guide","slug":"/operator-guide/auth-publisher","permalink":"/docs/operator-guide/auth-publisher","draft":false,"unlisted":false,"editUrl":"https://github.com/MystenLabs/walrus/tree/main/docs/../content/operator-guide/auth-publisher.mdx","tags":[],"version":"current","frontMatter":{"title":"The Authenticated Publisher","description":"Guide to setting up and using authenticated Walrus publishers with JWT authentication for controlled blob storage access.","keywords":["walrus","authenticated publisher","jwt","authentication","access control","mainnet","security","token verification"]},"sidebar":"operatorSidebar","previous":{"title":"Operating an Aggregator or Publisher","permalink":"/docs/operator-guide/aggregator"},"next":{"title":"Operating a Storage Node","permalink":"/docs/operator-guide/storage-node"}}');var i=n(2615),r=n(5756);let o={title:"The Authenticated Publisher",description:"Guide to setting up and using authenticated Walrus publishers with JWT authentication for controlled blob storage access.",keywords:["walrus","authenticated publisher","jwt","authentication","access control","mainnet","security","token verification"]},h,a={},l=[{value:"Understand the authentication flow",id:"understand-the-authentication-flow",level:2},{value:"Set up the publisher",id:"set-up-the-publisher",level:2},{value:"Set the JWT decode secret",id:"set-the-jwt-decode-secret",level:3},{value:"Choose an authentication algorithm",id:"choose-an-authentication-algorithm",level:3},{value:"Configure JWT expiration",id:"configure-jwt-expiration",level:3},{value:"Verify upload parameters",id:"verify-upload-parameters",level:3},{value:"Configure replay suppression",id:"configure-replay-suppression",level:3},{value:"Work with JWTs",id:"work-with-jwts",level:2},{value:"Mandatory fields",id:"mandatory-fields",level:3},{value:"Optional fields",id:"optional-fields",level:3},{value:"Create a valid JWT in the backend",id:"create-a-valid-jwt-in-the-backend",level:3},{value:"Rust",id:"rust",level:4}];function c(e){let t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components},{Term:n}=t;return n||function(e,t){throw Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Term",!0),(0,i.jsxs)(i.Fragment,{children:["\n",(0,i.jsxs)(t.p,{children:["The authenticated ",(0,i.jsx)(n,{lookup:"Publisher",children:"publisher"})," requires HTTP requests to store a ",(0,i.jsx)(n,{lookup:"Blob",children:"blob"})," to be authenticated. Use an authenticated ","publisher"," as a building block for services that require storing over HTTP on Walrus Mainnet, where an open ","publisher"," is undesirable because of the SUI and ",(0,i.jsx)(n,{lookup:"WAL",children:"WAL"})," cost of publishing to Walrus."]}),"\n",(0,i.jsxs)(t.p,{children:["Configure the Walrus ","Publisher"," to require a JWT (JSON Web Token) with each HTTP request for ",(0,i.jsx)(n,{lookup:"User",children:"user"})," authentication. The authentication system ensures that only authorized clients can store ","blobs"," and allows for fine-grained control over storage parameters through JWT claims."]}),"\n",(0,i.jsx)(t.p,{children:"The authenticated publishing flow occurs as follows:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsxs)(t.strong,{children:["Publisher"," setup"]}),": The ","publisher"," operator funds the ","publisher","'s wallet with sufficient SUI and ","WAL",", and configures the ","publisher"," to only accept authenticated requests. This entails setting the algorithm to authenticate JWTs, the expiration time for JWTs, and the JWT authentication secret."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Authentication channel setup"}),": The ","publisher"," operator sets up a channel through which users can obtain the JWT tokens. This step can be performed in any way that produces a valid JWT, and is not provided in this implementation."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsxs)(t.strong,{children:[(0,i.jsx)(n,{lookup:"Client",children:"Client"})," authentication"]}),": The ","client"," obtains a JWT token from the channel set up in the previous step. The JWT token can specify Walrus-relevant constraints, such as the maximum number of epochs the JWT can be used to store for, and the maximum size of the ","blobs"," being stored."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Publish request"}),": The ","client"," requests to store a ","blob"," using the ","publisher",". This is done through an HTTP PUT request containing the JWT in an Authorization Bearer HTTP header."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Store to Walrus"}),": The ","publisher"," checks the JWT, and checks that the store request is compliant with the constraints specified in the JWT, for example, the ","blob"," being stored is smaller than the authorized max size."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Optional: ",(0,i.jsx)(t.strong,{children:"Asset return"}),": If so specified, the ","publisher"," returns the newly-created ",(0,i.jsx)(t.code,{children:"Blob"})," object to the Sui Address set in the request."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"understand-the-authentication-flow",children:"Understand the authentication flow"}),"\n",(0,i.jsxs)(t.p,{children:["The authenticated ","publisher"," enables web apps to let users upload files to Walrus without requiring them to have a wallet. The following example demonstrates a typical workflow where users authenticate through the webapp using credentials like username and password rather than a blockchain wallet."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.strong,{children:["User"," authentication and upload request"]})}),"\n",(0,i.jsxs)(t.p,{children:["The ","user"," logs into the webapp and selects a file to upload. They choose how many epochs to store the file for. The webapp frontend sends the file size and epoch count to the backend."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Backend authorization and JWT generation"})}),"\n",(0,i.jsxs)(t.p,{children:["The backend verifies the ","user"," is authorized to store this amount of data for the requested duration. It checks:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["User"," quota and reduces it if needed"]}),"\n",(0,i.jsxs)(t.li,{children:["Cost of the upload in SUI and ","WAL"]}),"\n",(0,i.jsxs)(t.li,{children:["Whether the cost fits within the ","user","'s budget"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"This accounting can be done locally or directly on Sui. If authorized, the backend generates a JWT token containing the approved size and epoch limits, then sends it to the frontend."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsxs)(t.strong,{children:["Publisher"," request and verification"]})}),"\n",(0,i.jsxs)(t.p,{children:["The frontend sends the file to the ","publisher"," using a ",(0,i.jsx)(t.code,{children:"PUT"})," request with the JWT in the Authorization Bearer header. The ","publisher"," verifies:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Token signature matches the configured secret"}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Token has not expired"}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Token has not been used before (prevents replay attacks)"}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Upload parameters match the JWT claims (if verification is enabled)"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Storage and object return"})}),"\n",(0,i.jsxs)(t.p,{children:["If all checks pass, the ","publisher"," stores the file on Walrus. If configured, the ","publisher"," returns the created ",(0,i.jsx)(t.code,{children:"Blob"})," object to the specified Sui address."]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsx)(t.p,{children:"Each JWT token can only be used once. After storing 1 file, the replay suppression system rejects the token. Do not use JWT tokens for accounting purposes."})}),"\n",(0,i.jsxs)(t.h2,{id:"set-up-the-publisher",children:["Set up the ","publisher"]}),"\n",(0,i.jsxs)(t.p,{children:["Configure the ","publisher"," at startup using the following command line arguments:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"--jwt-decode-secret"}),": The secret key used to verify JWT signatures. If set, the ","publisher"," only stores ","blobs"," with valid JWTs."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"--jwt-algorithm"}),": The algorithm used for JWT verification (defaults to HMAC)."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"--jwt-expiring-sec"}),": Duration in seconds after which the JWT is considered expired."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"--jwt-verify-upload"}),": Enable verification of upload parameters against JWT claims."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"set-the-jwt-decode-secret",children:"Set the JWT decode secret"}),"\n",(0,i.jsxs)(t.p,{children:["The secret can be a hexadecimal string, starting with ",(0,i.jsx)(t.code,{children:"0x"}),". If this parameter is not specified, the authentication is disabled."]}),"\n",(0,i.jsxs)(t.p,{children:["All JWT tokens are expected to have the ",(0,i.jsx)(t.code,{children:"jti"})," (JWT ID) set in the claim to a unique value. The JWT is used for replay suppression, to avoid malicious users storing multiple times using the same JWT. Therefore, the JWT creator must ensure that this value is unique among all requests to the ","publisher",". Using large nonces to avoid collisions is recommended."]}),"\n",(0,i.jsx)(t.h3,{id:"choose-an-authentication-algorithm",children:"Choose an authentication algorithm"}),"\n",(0,i.jsx)(t.p,{children:"The following algorithms are supported: HS256, HS384, HS512, ES256, ES384, RS256, RS384, PS256, PS384, PS512, RS512, and EdDSA. The default JWT authentication algorithm is HS256."}),"\n",(0,i.jsx)(t.h3,{id:"configure-jwt-expiration",children:"Configure JWT expiration"}),"\n",(0,i.jsxs)(t.p,{children:["If the parameter is set and greater than 0, the ","publisher"," checks if the JWT token is expired based on the issued at (",(0,i.jsx)(t.code,{children:"iat"}),") value in the JWT token."]}),"\n",(0,i.jsx)(t.h3,{id:"verify-upload-parameters",children:"Verify upload parameters"}),"\n",(0,i.jsxs)(t.p,{children:["If set, the ","publisher"," verifies that the requested upload matches the claims in the JWT. This does not enable or disable the cryptographic authentication of the JWT; it just enables or disables the checks that ensure the contents of the JWT claim match the requested ","blob"," upload."]}),"\n",(0,i.jsxs)(t.p,{children:["Specifically, the ","publisher",":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Verifies that the number of ",(0,i.jsx)(t.code,{children:"epochs"})," in query is the same as ",(0,i.jsx)(t.code,{children:"epochs"})," in the JWT, if present."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Verifies that the ",(0,i.jsx)(t.code,{children:"send_object_to"})," field in the query is the same as the ",(0,i.jsx)(t.code,{children:"send_object_to"})," in the JWT, if present."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsx)(t.p,{children:"Verifies the size of uploaded file."}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:["Verifies the uniqueness of the ",(0,i.jsx)(t.code,{children:"jti"})," claim."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Disabling the parameter verification can be useful in case the source of the store requests is trusted, but the ","publisher"," can be contacted by untrusted sources. In that case, the authentication of the JWT is necessary, but not the verification of the upload parameters."]}),"\n",(0,i.jsx)(t.h3,{id:"configure-replay-suppression",children:"Configure replay suppression"}),"\n",(0,i.jsxs)(t.p,{children:["The ","publisher"," supports replay suppression to avoid the malicious reuse of JWT tokens."]}),"\n",(0,i.jsx)(t.p,{children:"The replay suppression supports the following configuration parameters:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"--jwt-cache-size"}),": The maximum size of the ","publisher","'s JWT ",(0,i.jsx)(n,{lookup:"Cache",children:"cache"}),", where the ",(0,i.jsx)(t.code,{children:"jti"})," JWT IDs of the used JWTs are kept until their expiration. This is a hard upperbound on the number of entries in the ","cache",", after which additional requests to store are rejected. This hard bound is introduced to avoid DoS attacks on the ","publisher"," through the ","cache","."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"--jwt-cache-refresh-interval"}),": The interval (in seconds) after which the ","cache"," is refreshed, and expired JWTs are removed (possibly creating space for additional JWTs to be inserted)."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"work-with-jwts",children:"Work with JWTs"}),"\n",(0,i.jsxs)(t.p,{children:["The current authenticated ","publisher"," implementation does not provide a way to generate the JWTs and distribute them to the clients. These can be generated with any tool (examples on how to create a JWT are given in the next section), as long as they respect the following constraints."]}),"\n",(0,i.jsx)(t.h3,{id:"mandatory-fields",children:"Mandatory fields"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"exp"})," (Expiration): Timestamp when the token expires."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"jti"})," (JWT ID): Unique identifier for the token to prevent replay attacks."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"optional-fields",children:"Optional fields"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"iat"})," (Issued At): Optional timestamp when the token was issued."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"send_object_to"}),": Optional Sui address where the newly-created ",(0,i.jsx)(t.code,{children:"Blob"})," object should be sent."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"epochs"}),": Optional exact number of epochs the ","blob"," should be stored for."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"max_epochs"}),": Optional maximum number of epochs the ","blob"," can be stored for."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"max_size"}),": Optional maximum size of the ","blob"," in bytes."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"size"}),": Optional exact size of the ","blob"," in bytes."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"epochs"})," and ",(0,i.jsx)(t.code,{children:"max_epochs"})," claims cannot be used together, and neither can ",(0,i.jsx)(t.code,{children:"size"})," and ",(0,i.jsx)(t.code,{children:"max_size"}),". Using both in either case results in token rejection."]}),"\n",(0,i.jsxs)(t.p,{children:["Importantly, the JWT can only encode information on the size and epochs of the ","blob"," to store, and not on the amount of SUI and ","WAL"," the ","user"," is allowed to consume. This should be done on the backend, before issuing the JWT."]}),"\n",(0,i.jsx)(t.h3,{id:"create-a-valid-jwt-in-the-backend",children:"Create a valid JWT in the backend"}),"\n",(0,i.jsxs)(t.p,{children:["The following examples show how to create JWTs that can be consumed by the authenticated ","publisher","."]}),"\n",(0,i.jsx)(t.h4,{id:"rust",children:"Rust"}),"\n",(0,i.jsxs)(t.p,{children:["In Rust, the ",(0,i.jsx)(t.a,{href:"https://docs.rs/jsonwebtoken/latest/jsonwebtoken/",children:(0,i.jsx)(t.code,{children:"jsonwebtoken"})})," crate can be used to create JWTs."]}),"\n",(0,i.jsxs)(t.p,{children:["In the code, the following struct is used to deserialize the incoming tokens in the ","publisher"," (see the ",(0,i.jsx)(t.a,{href:"https://github.com/MystenLabs/walrus/blob/main/crates/walrus-service/src/client/daemon/auth.rs",children:"code"})," for the complete version)."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"pub struct Claim {\n    pub iat: Option<i64>,\n    pub exp: i64,\n    pub jti: String,\n    pub send_object_to: Option<SuiAddress>,\n    pub epochs: Option<u32>,\n    pub max_epochs: Option<u32>,\n    pub size: Option<u64>,\n    pub max_size: Option<u64>,\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"The same struct can be used to create and then encode valid tokens in Rust. This is something along the lines of:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:'use jsonwebtoken::{encode, Algorithm, EncodingKey, Header};\n\n...\n\nlet encoding_key = EncodingKey::from_secret("my_secret".as_bytes());\nlet claim = Claim { /* set here the parameters for the Claim struct above */ };\nlet jwt = encode(&Header::default(), &claim, &encode_key).expect("a valid claim and key");\n'})})]})}function d(e={}){let{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);