"use strict";(globalThis.webpackChunkwalrus_docusaurus=globalThis.webpackChunkwalrus_docusaurus||[]).push([[2640],{1938(e,r,o){o.r(r),o.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>t,toc:()=>c});let t=JSON.parse('{"id":"design/properties","title":"Walrus Assurance and Security Properties","description":"Detailed security properties and assurances of Walrus including point of availability, consistency guarantees, and Byzantine fault tolerance.","source":"@site/../content/design/properties.mdx","sourceDirName":"design","slug":"/design/properties","permalink":"/docs/design/properties","draft":false,"unlisted":false,"editUrl":"https://github.com/MystenLabs/walrus/tree/main/docs/../content/design/properties.mdx","tags":[],"version":"current","frontMatter":{"title":"Walrus Assurance and Security Properties","description":"Detailed security properties and assurances of Walrus including point of availability, consistency guarantees, and Byzantine fault tolerance.","keywords":["walrus","security properties","point of availability","consistency","byzantine fault tolerance","availability period","assurance","erasure coding"]}}');var n=o(2615),i=o(5756);let s={title:"Walrus Assurance and Security Properties",description:"Detailed security properties and assurances of Walrus including point of availability, consistency guarantees, and Byzantine fault tolerance.",keywords:["walrus","security properties","point of availability","consistency","byzantine fault tolerance","availability period","assurance","erasure coding"]},a,l={},c=[{value:"Key concepts",id:"key-concepts",level:2},{value:"Point of availability (PoA)",id:"point-of-availability-poa",level:3},{value:"Read and write properties",id:"read-and-write-properties",level:2},{value:"Storage node assurance",id:"storage-node-assurance",level:2}];function d(e){let r={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{Term:o}=r;return o||function(e,r){throw Error("Expected "+(r?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Term",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:["The following properties are true for all storage epochs where at least 2/3 of shards are operated by ",(0,n.jsx)(o,{lookup:"Storage node",children:"storage nodes"})," that faithfully and correctly follow the Walrus protocol."]}),"\n",(0,n.jsx)(r.h2,{id:"key-concepts",children:"Key concepts"}),"\n",(0,n.jsxs)(r.p,{children:["Each ",(0,n.jsx)(o,{lookup:"Blob",children:"blob"})," undergoes ",(0,n.jsx)(r.a,{href:"/docs/design/encoding",children:"erasure encoding"})," into slivers, and a ",(0,n.jsx)(o,{lookup:"Blob ID",children:"blob ID"})," is cryptographically derived from this encoding."]}),"\n",(0,n.jsx)(r.h3,{id:"point-of-availability-poa",children:(0,n.jsx)(o,{lookup:"Point of availability",children:"Point of availability (PoA)"})}),"\n",(0,n.jsxs)(r.p,{children:["For each stored ","blob ID",", Walrus defines a ","PoA"," that marks when the system takes responsibility for maintaining the ","blob","'s availability."]}),"\n",(0,n.jsxs)(r.p,{children:["The ",(0,n.jsx)(r.strong,{children:(0,n.jsx)(o,{lookup:"Availability period",children:"availability period"})})," specifies how long Walrus maintains a ","blob"," after its ","PoA",". Both the ","PoA"," and ","availability period"," are observable through events on Sui."]}),"\n",(0,n.jsxs)(r.p,{children:["Before the ","PoA",", the ",(0,n.jsx)(o,{lookup:"Client",children:"client"})," is responsible for ensuring ","blob"," availability and uploading it to Walrus."]}),"\n",(0,n.jsxs)(r.p,{children:["After the ","PoA",", Walrus is responsible for maintaining ","blob"," availability for the full ","availability period",". The ","PoA"," is observable through an event on the Sui chain, and this event attests to the ","blob","'s availability in the system."]}),"\n",(0,n.jsx)(r.h2,{id:"read-and-write-properties",children:"Read and write properties"}),"\n",(0,n.jsxs)(r.p,{children:["The following properties relate to the ","PoA",":"]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:"Read completion:"})," After the ","PoA"," for a ","blob ID",", any correct ",(0,n.jsx)(o,{lookup:"User",children:"user"})," performing a read within the ","availability period"," will eventually terminate and receive a value (V). This value is either the ","blob"," contents (F) or ",(0,n.jsx)(r.code,{children:"None"}),"."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:"Read consistency:"})," After the ","PoA",", if two correct users perform reads and receive values (V) and (V') respectively, then (V = V'). All correct readers see the same value."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:"Correct storage guarantee:"})," A correct ","user"," with an appropriate storage resource can always perform a store operation for a ","blob"," (F) with a ","blob ID"," and advance the protocol until the ","PoA","."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsxs)(r.strong,{children:["Correct ","blob"," retrieval:"]})," A read after the ","PoA"," for a ","blob"," (F) stored by a correct ","user"," will return (F). Correctly stored ","blobs"," are always retrievable."]}),"\n"]}),"\n",(0,n.jsxs)(r.h2,{id:"storage-node-assurance",children:["Storage node"," assurance"]}),"\n",(0,n.jsxs)(r.p,{children:["Some assurance properties ensure the correct internal processes of Walrus ","storage nodes",". For the purposes of defining these, an ",(0,n.jsx)(r.strong,{children:(0,n.jsx)(o,{lookup:"Inconsistency proof",children:"inconsistency proof"})})," proves that a ","blob ID"," was stored by a ","user"," that incorrectly encoded a ","blob",":"]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsxs)(r.strong,{children:[(0,n.jsx)(o,{lookup:"Shard recovery",children:"Sliver recovery"}),":"]})," After the ","PoA",", for a ","blob ID"," stored by a correct ","user",", a ","storage node"," can always recover the correct slivers for its shards for this ","blob ID","."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:"Inconsistency detection:"})," After the ","PoA",", if a correct ","storage node"," cannot recover a ",(0,n.jsx)(o,{lookup:"Sliver",children:"sliver"}),", it can produce an ","inconsistency proof"," for the ","blob ID","."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.strong,{children:"Encoding protection:"})," If a ","blob ID"," is stored by a correct ","user",", an ","inconsistency proof"," cannot be derived for it."]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsxs)(r.strong,{children:["Inconsistent ","blob"," handling:"]})," A read by a correct ","user"," for a ","blob ID"," for which an ","inconsistency proof"," might exist returns ",(0,n.jsx)(r.code,{children:"None"}),"."]}),"\n"]})]})}function u(e={}){let{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},5756(e,r,o){o.d(r,{R:()=>s,x:()=>a});var t=o(9471);let n={},i=t.createContext(n);function s(e){let r=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),t.createElement(i.Provider,{value:r},e.children)}}}]);